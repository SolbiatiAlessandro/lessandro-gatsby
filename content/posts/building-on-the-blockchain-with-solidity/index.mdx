---
title: Building on the Blockchain with Solidity
date: 2020-11-20
tags:
  - blockchain
  - programming
---

I have been turning away from this Blockchain technology because of the major hype that has been happening in the last 5 years. Now that the hype is finally going down looks like is time to have a look at it...

### Triggered by Yuval Noah Harari (YNH)

I was re-reading [Sapiens from YNH](https://www.ynharari.com/book/sapiens/) where he speaks about how things like money or Facebook are just [social contracts](https://en.wikipedia.org/wiki/Social_contract), i.e. imagined realities that everyone believes in, and as long as this communal belief persist, the imagined reality exerts force in the world. This somehow ringed the bell of [smart contracts](https://github.com/ethereumbook/ethereumbook/blob/develop/07smart-contracts-solidity.asciidoc#what-is-a-smart-contract). I am not sure (yet) if the two things are related, but my brain works through random association so this totally justify me spending the afternoon on the [Ethereum developer tutorial](https://ethereum.org/build/) right?

### Hello World in Solidity

Usually you check how complicated is to write a hello world to sample the complexity of a language, well the [Solidity hello world](https://kauri.io/create-a-%22hello-world%22-fullstack-dapp/68fca74301814d09bfcc35e07ff30fbc/a) is in the hard end of the spectrum. I am unfamiliar with dozens of concepts so I will try to go through one by one.

*   [Solidity](https://solidity.readthedocs.io/en/v0.5.3/index.html) is the OOP language for implementing smart contract on the Etherum blockchain, and it looks like Java (weird syntax choice for 2020 IMHO). [web3.js](https://web3js.readthedocs.io/en/v1.2.4/) is the Javascript library to interact via HTTP with Ethereum nodes that run Solidity code (aka smart contract).
*   [Smart Contract](https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html#simple-smart-contract) is a Solidity class with attributes (aka data) and methods (aka functions). The whole point here is that an instance of this Smart Contract class becomes a node in the BlockChain and anyone in the world can access it (as in a public distributed database).
*   [Cryptocurrency](https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html#subcurrency-example) is an example of a Solidity class (aka smart contract) that implements some methods like "create new coins" (aka mint), "send/receive money"; intuitively, this class is smart contract because it implements rules like "require(balance > X) => send X coins".
*   [BlockChain](https://solidity.readthedocs.io/en/v0.5.3/introduction-to-smart-contracts.html#subcurrency-example) is the database where you record transactions (aka blocks), i.e. calling methods of a Smart Contract. For example, when you call the "mint" method of a Cryptocurrency class, you are adding a new block (making a new insert transaction) into the database (aka blockchain). This blocks form a linear sequence in time and practically can't be reverted.

### Building a Zombie mini-game on the BlockChain

Being a strong advocate for project based learning, I got lured by [cryptozombies.io](https://cryptozombies.io/) that offer an interactive Solidity tutorial around mini-games. It's a freemium 11 lessons interactive tutorial similar to codeacademy. These are more or less the topics they go through:

*   [Building a Smart-Contract](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-1/chapter-13/Contract.sol): at the end of the day building the smart-contract looks like implementing a Java backend of a web application. You can emit events that you will be listening from the Javascript front-end, and you have a distinction of pure/view private/public functions, but for the basic that's mainly it. You can look at the [source code here.](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-1/chapter-13/Contract.sol)
*   [Interact with other Smart-Contracts on the BlockChain](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-2/chapter-13/zombiefeeding.sol): now stuff start to become fun. Turns out that you can instantiate a Smart-Contract that already exist on the BlockChain inside your own Smart-Contract implementation and interact with it through an interface class. Let's take the [KittyCore contract](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code) for example; this is the core contract used by the fairly popular [CryptoKitties.co](https://www.cryptokitties.co/), a marketplace where the digital assets you trade are virtual cats. The KittyCore contract is a Solidity class that lives at a uniquely defined hash on the Ethereum BlockChain, specifically [0x06012//](https://etherscan.io/token/0x06012c8cf97bead5deae237070f9587f8e7a266d). You can actually [read the code of this class](https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code), and see that it implements functions like getKitty(uint \_id) that you can call once you instantiate the KittyCore contract through a local interface in your smart contract! [In this repo](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-2/chapter-13/zombiefeeding.sol) is an example Smart-Contract implementation that has read access to the CryptoKitties decentralised database. Something even more interesting is to [have a look on EtherScan](https://etherscan.io/token/0x06012c8cf97bead5deae237070f9587f8e7a266d) at the transactions that happens real time with the KittyCore contract and other contracts: [0x662de//](https://etherscan.io/tx/0x662de43710641b04fc07a192528018bab8068ec7c71bc23a12d7dd9c6e82bd94) is a transaction that has bid(1317377) as input data, this means someone is calling the bid of the KittyCore Smart-Contract: you can actually go on [opensea.io](opensea.io) and look for the [CryptoKitty with ID 1317377](https://opensea.io/assets/0x06012c8cf97bead5deae237070f9587f8e7a266d/1317377), a.k.a "Fuku Bummuffin", and confirm the actual trade activity we just saw from etherscan! That was interesting.
*   [Smart-Contracts implementation best practices](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-3/chapter-12/zombiehelper.sol): there are some non-trivial considerations around computational complexity when implementing a smart-contract. [ethgasstation.info](https://ethgasstation.info/) provides a real-time view of prices for computational power (referred as gas market) on the Ethereum Blockchain. As a distributed computation system, the computation need to be replicated in different nodes of the network, and you pay a fee to this nodes that execute your code i.e. the miners. Here is a nice [explanation of gas prices and gas markets.](https://ethgasstation.info/blog/what-is-gas/) You can see in the repo at lesson 3 some [example of code optimisations](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-3/chapter-12/zombiehelper.sol) to reduce the distributed computation complexity of the smart-contract in order to minimise the transaction cost (a.k.a gas fee).
*   [Interacting in a Marketplace through Tokens and Payable](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-5/chapter-13/zombieownership.sol). Is a good practice to use standard interfaces of Smart-Contracts, known as tokens. A standard interface allows any tokens on Ethereum to be re-used by other applications: from wallets to decentralized exchanges. You can view the [OpenZeppelin implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token) for the major tokens around. The two most famous are [ERC-20](https://eips.ethereum.org/EIPS/eip-20), used to implement currencies where every token is identical to another (fungible), and [ERC-271](http://erc721.org/) used to implement unique assets (like CryptoKitties mentioned above). This interfaces has functions like transferFrom that should implement the transferral of the asset between owners. An interesting property of this functions is that they possess the [payable modifier](https://ethereum.stackexchange.com/questions/20874/payable-function-in-solidity), that allows the caller to send an amount of Ether tokens when calling the function. This is an elegant approach to model financial transaction on the Ethereum Blockchain. You can [read the tutorial code](https://github.com/loomnetwork/cryptozombies-lesson-code/blob/master/lesson-5/chapter-13/zombieownership.sol) for implementation of ERC721 payable functions.
*   Deploying Smart-Contracts on the BlockChain: there is a vibrant ecosystem of services that help you put your Smart-Contracts to life on the BlockChain. The central one is [Truffle](https://www.trufflesuite.com/) a Javascript SDK to manage the deployment process. There is [Infura](https://infura.io/) and [RinkeBy](https://www.rinkeby.io/) test network.